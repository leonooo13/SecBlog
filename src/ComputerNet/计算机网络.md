# OSI七层模型
1. 物理层
2. 数据链路层
3. 网络层
4. 传输层
5. 会话层
6. 表示层
7. 应用层
# TCP/IP层
1. 网络接口层
2. 网络层
3. 传输层
4. 应用层
# 键入网站到浏览器显示会发生什么？
1. URL解析 ：进行编码
2. DNS查询
3. TCP连接
4. 处理请求
5. 接受响应
6. 页面渲染
7. 
浏览器键入url，首先检测本地dns看里面有没有对应的IP地址，如果有访问该IP对应的服务器，如果没有访问dns服务器来获取IP，有递归查询和迭代查询两种方案，物理实体上需要用到MAC地址, #ARP协议 此时的帧：以太网首部和相应的数据部分，在网络层此时用到 #IP协议 `|IP首部|IP的数据部分`，访问服务器后需要使用到TCP/UDP协议来进行端到端的信息传输，就是某项服务与服务之间，IP数据报的数据部分拆开，里面有TCP的报文格式为`|TCP首部|TCP数据部分|`，因为接收方能力的原因，对TCP有发送也设置了限制，比如流量控制和拥塞控制。在应用层接受HTTP数据到服务器，服务器发送响应，浏览器进行渲染。
![[Pasted image 20230417193035.png]]
浏览器发送：请求报文
```html
请求行：GET/POST
消息头：
消息体：
```
服务器发送：响应报文
```html
状态行:状态码
消息头
消息体
```
在浏览器中键入的是：域名，服务器中公网中暴漏的是IP
故此Windows首先是根据本地host文件来映射域名--->IP，倘若host文件中没有，需要根据DNS服务器来找到对应的IP地址，
## 域名服务器的类型
类型树形结构
根域名服务器-->顶级域名服务器--->权限域名服务器
## 域名查询
1. 迭代查询
	本地主机首先查询本地域名服务器，如果没有查到就去查询，本地域名服务器以DNS客户找根域名服务器如`xxx.com`，然后去查询顶级域名服务器，查询权限域名服务器，之后放过来一步步交给本地域名服务器。
2. 递归查询
	同样的本地主机查询本地域名服务器，如果没有找到，向根域名服务器发起请求，根域名服务器要么给出IP，要么给出你下一步去哪个域名服务器，一步步查询。
## 操作系统
应用程序：`socket`
操作系统：TCP/UDP/IP (ICMP ARP)
驱动程序：网卡驱动程序
硬件：物理硬件网卡
### 可靠传输：`TCP`
报文格式
源端口号 16bit                                                    目的端口号16bit
									序号 32bit
									确认序号 32bit
首部长度 4bit 保留 6bit URG ACK RST SYN FIN  窗口大小 16bit
校验和 16bit                                                        紧急指针 16bit
									选项
									数据
> 注：由于TCP是端对端的连接，目的端口和源端口是不可少的
> 序号是用来将混乱的包，重新组装。
> 状态位：
`SYN`   synchronous 建立连接
`ACK` acknowledgement 确认
`FIN` finish 结束
TCP中的窗口大小要做流量控制，让对面知道我所能接受的窗口大小。
TCP还要做拥塞控制。
## #TCP/UDP端口分配
10bit 是固定
